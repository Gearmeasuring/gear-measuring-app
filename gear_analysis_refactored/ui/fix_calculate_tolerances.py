import sys
import os

# Read the file
try:
    with open('tolerance_dialog.py', 'r', encoding='utf-8', errors='ignore') as f:
        content = f.read()
    
    # Find the calculate_tolerances method
    start = content.find('def calculate_tolerances')
    end = content.find('def toggle_header_mode', start)
    
    if start != -1 and end != -1:
        # Create the new method content
        new_method = "    def calculate_tolerances(self, type_):\n"
        new_method += "        \"\"\"Set tolerance values based on quality level using predefined lookup tables\"\"\"\n"
        new_method += "        try:\n"
        new_method += "            # Get quality level from the current page's spin box\n"
        new_method += "            # This direct approach works regardless of how pages are created\n"
        new_method += "            current_widget = self.content_stack.currentWidget()\n"
        new_method += "            if current_widget:\n"
        new_method += "                # Find all spin boxes in the current widget\n"
        new_method += "                spin_boxes = current_widget.findChildren(QSpinBox)\n"
        new_method += "                for spin_box in spin_boxes:\n"
        new_method += "                    # Check if this is likely the quality spin box (range 1-12)\n"
        new_method += "                    if spin_box.minimum() == 1 and spin_box.maximum() == 12:\n"
        new_method += "                        Q = spin_box.value()\n"
        new_method += "                        break\n"
        new_method += "                else:\n"
        new_method += "                    # If no quality spin box found, use default\n"
        new_method += "                    Q = 5\n"
        new_method += "            else:\n"
        new_method += "                Q = 5\n"
        new_method += "                \n"
        new_method += "            if type_ == \"profile\":\n"
        new_method += "                tolerance_table = {\n"
        new_method += "                    1: (3.0, 4.0, 5.0),\n"
        new_method += "                    2: (4.0, 6.0, 7.0),\n"
        new_method += "                    3: (5.5, 8.0, 10.0),\n"
        new_method += "                    4: (8.0, 12.0, 14.0),\n"
        new_method += "                    5: (11.0, 16.0, 20.0),\n"
        new_method += "                    6: (16.0, 22.0, 28.0),\n"
        new_method += "                    7: (22.0, 32.0, 40.0),\n"
        new_method += "                    8: (28.0, 45.0, 56.0),\n"
        new_method += "                    9: (40.0, 63.0, 80.0),\n"
        new_method += "                    10: (71.0, 110.0, 125.0),\n"
        new_method += "                    11: (110.0, 160.0, 200.0),\n"
        new_method += "                    12: (180.0, 250.0, 320.0)\n"
        new_method += "                }\n"
        new_method += "                \n"
        new_method += "                # Get tolerance values for the selected quality level\n"
        new_method += "                if Q in tolerance_table:\n"
        new_method += "                    fHa, ffa, Fa = tolerance_table[Q]\n"
        new_method += "                else:\n"
        new_method += "                    # Default to quality level 5 if out of range\n"
        new_method += "                    fHa, ffa, Fa = tolerance_table[5]\n"
        new_method += "                \n"
        new_method += "                # Update UI - set all quality fields to the selected quality level\n"
        new_method += "                for side in ['left', 'right']:\n"
        new_method += "                    # Update all quality fields to show the selected quality level\n"
        new_method += "                    for code in self.profile_inputs:\n"
        new_method += "                        if \"_check\" not in code and side in self.profile_inputs[code]:\n"
        new_method += "                            if 'qual' in self.profile_inputs[code][side]:\n"
        new_method += "                                qual_field = self.profile_inputs[code][side]['qual']\n"
        new_method += "                                if isinstance(qual_field, QLineEdit):\n"
        new_method += "                                    qual_field.setText(str(Q))\n"
        new_method += "                    \n"
        new_method += "                    # Update tolerance values with fixed values from lookup table\n"
        new_method += "                    self.profile_inputs['fHa'][side]['upp'].setText(f\"{fHa:.1f}\")\n"
        new_method += "                    self.profile_inputs['fHa'][side]['low'].setText(f\"{-fHa:.1f}\")\n"
        new_method += "                    \n"
        new_method += "                    self.profile_inputs['ffa'][side]['upp'].setText(f\"{ffa:.1f}\")\n"
        new_method += "                    \n"
        new_method += "                    self.profile_inputs['Fa'][side]['upp'].setText(f\"{Fa:.1f}\")\n"
        new_method += "                    \n"
        new_method += "                    # Var doesn't have quality field in the visible columns, set to 0.0\n"
        new_method += "                    if 'Var' in self.profile_inputs:\n"
        new_method += "                        self.profile_inputs['Var'][side]['upp'].setText(\"0.0\")\n"
        new_method += "\n"
        new_method += "            elif type_ == \"lead\":\n"
        new_method += "                # Fixed tolerance values for Lead (fHb, ffb, Fb) based on user images\n"
        new_method += "                # Quality level: (fHb, ffb, Fb)\n"
        new_method += "                lead_tolerance_table = {\n"
        new_method += "                    1: (2.5, 2.0, 3.0),\n"
        new_method += "                    2: (3.5, 5.0, 6.0),\n"
        new_method += "                    3: (4.5, 7.0, 8.0),\n"
        new_method += "                    4: (6.0, 8.0, 10.0),\n"
        new_method += "                    5: (8.0, 9.0, 12.0),\n"
        new_method += "                    6: (11.0, 12.0, 16.0),\n"
        new_method += "                    7: (16.0, 16.0, 22.0),\n"
        new_method += "                    8: (22.0, 25.0, 32.0),\n"
        new_method += "                    9: (32.0, 40.0, 50.0),\n"
        new_method += "                    10: (50.0, 63.0, 80.0),\n"
        new_method += "                    11: (80.0, 100.0, 125.0),\n"
        new_method += "                    12: (125.0, 160.0, 200.0)\n"
        new_method += "                }\n"
        new_method += "                \n"
        new_method += "                if Q in lead_tolerance_table:\n"
        new_method += "                    fHb, ffb, Fb = lead_tolerance_table[Q]\n"
        new_method += "                else:\n"
        new_method += "                    # Fallback to calculation for other levels\n"
        new_method += "                    width = float(self.gear_data.get('width', 0) or 0)\n"
        new_method += "                    factor = 2 ** (0.5 * (Q - 5))\n"
        new_method += "                    \n"
        new_method += "                    # Approximations\n"
        new_method += "                    if width > 0:\n"
        new_method += "                        fHb = (0.3 * width**0.5 + 4.0) * factor \n"
        new_method += "                    else:\n"
        new_method += "                        fHb = 10.0 * factor\n"
        new_method += "\n"
        new_method += "                    ffb = fHb * 0.8\n"
        new_method += "                    Fb = fHb * 1.2\n"
        new_method += "                \n"
        new_method += "                for side in ['left', 'right']:\n"
        new_method += "                    # Update ALL quality fields\n"
        new_method += "                    for code in self.lead_inputs:\n"
        new_method += "                        if \"_check\" not in code and side in self.lead_inputs[code]:\n"
        new_method += "                            if 'qual' in self.lead_inputs[code][side]:\n"
        new_method += "                                self.lead_inputs[code][side]['qual'].setText(str(Q))\n"
        new_method += "\n"
        new_method += "                    # Update calculated tolerances\n"
        new_method += "                    self.lead_inputs['fHb'][side]['upp'].setText(f\"{fHb:.1f}\")\n"
        new_method += "                    self.lead_inputs['fHb'][side]['low'].setText(f\"{-fHb:.1f}\")\n"
        new_method += "                    \n"
        new_method += "                    self.lead_inputs['ffb'][side]['upp'].setText(f\"{ffb:.1f}\")\n"
        new_method += "                    \n"
        new_method += "                    self.lead_inputs['Fb'][side]['upp'].setText(f\"{Fb:.1f}\")\n"
        new_method += "\n"
        new_method += "            elif type_ == \"spacing\":\n"
        new_method += "                # Tolerance values from user images for Q=1 to Q=12\n"
        new_method += "                # Format: (fp, fu, Fp, Fpz/8, Fr, Rs)\n"
        new_method += "                spacing_lookup = {\n"
        new_method += "                    1: (3.0, 4.0, 9.0, 6.0, 7.0, 4.5),\n"
        new_method += "                    2: (4.5, 5.5, 14.0, 8.0, 10.0, 7.0),\n"
        new_method += "                    3: (6.0, 8.0, 18.0, 11.0, 14.0, 9.0),\n"
        new_method += "                    4: (8.0, 10.0, 25.0, 16.0, 20.0, 12.0),\n"
        new_method += "                    5: (12.0, 16.0, 36.0, 22.0, 28.0, 18.0),\n"
        new_method += "                    6: (16.0, 20.0, 45.0, 32.0, 40.0, 25.0),\n"
        new_method += "                    7: (22.0, 28.0, 71.0, 40.0, 56.0, 36.0),\n"
        new_method += "                    8: (32.0, 40.0, 90.0, 63.0, 80.0, 50.0),\n"
        new_method += "                    9: (45.0, 56.0, 125.0, 80.0, 110.0, 71.0),\n"
        new_method += "                    10: (71.0, 90.0, 200.0, 140.0, 160.0, 100.0),\n"
        new_method += "                    11: (110.0, 140.0, 320.0, 220.0, 220.0, 140.0),\n"
        new_method += "                    12: (180.0, 220.0, 560.0, 320.0, 320.0, 180.0)\n"
        new_method += "                }\n"
        new_method += "                \n"
        new_method += "                if Q in spacing_lookup:\n"
        new_method += "                    fp, fu, Fp, Fpz8, Fr, Rs = spacing_lookup[Q]\n"
        new_method += "                else:\n"
        new_method += "                    # For Q > 12, extrapolate from Q=12 values using ISO factor\n"
        new_method += "                    # factor = 2^(0.5 * (Q - 12))\n"
        new_method += "                    base_values = spacing_lookup[12]\n"
        new_method += "                    factor = 2 ** (0.5 * (Q - 12))\n"
        new_method += "                    \n"
        new_method += "                    fp = base_values[0] * factor\n"
        new_method += "                    fu = base_values[1] * factor\n"
        new_method += "                    Fp = base_values[2] * factor\n"
        new_method += "                    Fpz8 = base_values[3] * factor\n"
        new_method += "                    Fr = base_values[4] * factor\n"
        new_method += "                    Rs = base_values[5] * factor\n"
        new_method += "                \n"
        new_method += "                # Update Spacing Group (Left/Right)\n"
        new_method += "                for side in ['left', 'right']:\n"
        new_method += "                    # Update Quality fields\n"
        new_method += "                    for code in ['fp', 'fu', 'Fp', 'Fpz/8']:\n"
        new_method += "                        if code in self.spacing_inputs and side in self.spacing_inputs[code]:\n"
        new_method += "                            if 'qual' in self.spacing_inputs[code][side]:\n"
        new_method += "                                self.spacing_inputs[code][side]['qual'].setText(str(Q))\n"
        new_method += "                        \n"
        new_method += "                    # Update Values\n"
        new_method += "                    if 'fp' in self.spacing_inputs and side in self.spacing_inputs['fp']:\n"
        new_method += "                        self.spacing_inputs['fp'][side]['upp'].setText(f\"{fp:.1f}\")\n"
        new_method += "                    if 'fu' in self.spacing_inputs and side in self.spacing_inputs['fu']:\n"
        new_method += "                        self.spacing_inputs['fu'][side]['upp'].setText(f\"{fu:.1f}\")\n"
        new_method += "                    if 'Fp' in self.spacing_inputs and side in self.spacing_inputs['Fp']:\n"
        new_method += "                        self.spacing_inputs['Fp'][side]['upp'].setText(f\"{Fp:.1f}\")\n"
        new_method += "                    if 'Fpz/8' in self.spacing_inputs and side in self.spacing_inputs['Fpz/8']:\n"
        new_method += "                        self.spacing_inputs['Fpz/8'][side]['upp'].setText(f\"{Fpz8:.1f}\")\n"
        new_method += "                    \n"
        new_method += "                # Update Run-out Group (Single)\n"
        new_method += "                # Fr\n"
        new_method += "                if 'Fr' in self.spacing_inputs:\n"
        new_method += "                    if 'qual' in self.spacing_inputs['Fr']: self.spacing_inputs['Fr']['qual'].setText(str(Q))\n"
        new_method += "                    if 'upp' in self.spacing_inputs['Fr']: self.spacing_inputs['Fr']['upp'].setText(f\"{Fr:.1f}\")\n"
        new_method += "                    \n"
        new_method += "                # Rs\n"
        new_method += "                if 'Rs' in self.spacing_inputs:\n"
        new_method += "                    if 'qual' in self.spacing_inputs['Rs']: self.spacing_inputs['Rs']['qual'].setText(str(Q))\n"
        new_method += "                    if 'upp' in self.spacing_inputs['Rs']: self.spacing_inputs['Rs']['upp'].setText(f\"{Rs:.1f}\")\n"
        new_method += "                    \n"
        new_method += "        except Exception as e:\n"
        new_method += "            QMessageBox.warning(self, \"Error\", f\"Calculation failed: {e}\")\n"
        
        # Replace the old method with the new one
        updated_content = content[:start] + new_method + content[end:]
        
        # Write the updated content back to the file
        with open('tolerance_dialog.py', 'w', encoding='utf-8') as f:
            f.write(updated_content)
            
        print("Successfully updated calculate_tolerances method!")
    else:
        print("Could not find calculate_tolerances method or toggle_header_mode method!")
    
except Exception as e:
    print(f"Error: {e}")
    import traceback
    traceback.print_exc()
